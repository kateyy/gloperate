#version 430
#extension GL_ARB_shading_language_include : require

layout (local_size_x = 16, local_size_y = 16) in;

#include </data/pathtracing/generic/random.glsl>
#include </data/pathtracing/generic/rayCast.glsl>
#include </data/pathtracing/generic/sampling.glsl>

#include </PATHTRACING_EXTENSIONS/materials>


layout (std430, binding = 1) writeonly buffer PathStackDataBuffer
{
	PathStackData pathStackData[];
};

layout (std430, binding = 2) readonly buffer InputRays
{
	SecondOrderRay inputRays[];
};

layout (std430, binding = 3) writeonly buffer OutputRays
{
	SecondOrderRay outputRays[];
};

layout (binding = 0, offset = 0) uniform atomic_uint rayIndexCounter;

uniform uint frameCounter;
uniform uint time;
uniform uint numRays;
uniform uint stride;
uniform uint depth;
uniform ivec2 viewportSize;


// required
bool rayCast(in Ray ray, out RayIntersection intersection);
void getMaterial(in RayIntersection intersection, out PathStackData stackData);


void main()
{
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	int rayIndex = pos.y*int(stride)+pos.x;

	if (rayIndex >= numRays)
		return;

	random_seed(vec2(pos) / vec2(stride), int(depth * frameCounter + time));

    SecondOrderRay inputRay = inputRays[rayIndex];
    Ray ray = Ray_new(inputRay.origin, inputRay.direction);

    RayIntersection intersection;
    bool rayHit = rayCast(ray, intersection);

    if (rayHit)
    {
        uint nextRaysIndex = atomicCounterIncrement(rayIndexCounter);
        outputRays[nextRaysIndex].pixel = inputRay.pixel;
        outputRays[nextRaysIndex].origin = intersection.nextRay.origin;
        outputRays[nextRaysIndex].direction = intersection.nextRay.direction;
    }


    PathStackData stackData;
    if (rayHit)
        getMaterial(intersection, stackData);
    else
    {
        stackData.materialID = -1;
        stackData.lightColor.xyz = ray.direction;
    }


    uint index = pixelCoordsToIndex(inputRay.pixel, viewportSize);
    pathStackData[index] = stackData;
}
