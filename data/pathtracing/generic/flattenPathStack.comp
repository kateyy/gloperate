#version 430
#extension GL_ARB_shading_language_include : require

layout (local_size_x = 16, local_size_y = 16) in;

#include </data/pathtracing/generic/dataTypes.glsl>
#include </data/pathtracing/generic/sampling.glsl>

#include </PATHTRACING_EXTENSIONS/geometryTraversal>
#include </PATHTRACING_EXTENSIONS/materials>


layout (std430, binding = 1) readonly buffer PathStackDataBuffer
{
    PathStackData pathStackData[];
};

uniform uint frameCounter;
uniform uint numStackLayers; // == 1 means ray casting, == 2 emits one second order ray ...
uniform uvec2 layerSize;
uniform uint layerStride;


layout (binding = 0, rgba32f) uniform image2D colorTexture;


void main()
{
    // coarse sampling / anti-aliasing: see sampling.glsl
    bool coarseSamplingInit;
    uint coarseSubSampleId = getCoarseSubSampleId(frameCounter, coarseSamplingInit);

	CoarseSamplingWindow coarseWindow = coarseSamplingWindows[coarseSubSampleId];

	// trace the origin of the coarse window (minimal coordinate)
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy * coarseSamplingWindowSize + coarseWindow.origin);
    
    if (pixelCoords.x >= layerSize.x || pixelCoords.y >= layerSize.y)
        return;
    
    uint pixelIndex = pixelCoordsToIndex(pixelCoords, ivec2(layerSize));
    uint elementsPerLayer = layerSize.x * layerSize.y + layerStride;

    PathStackData data;
    vec4 color = vec4(0.0);
    
    int layer = int(numStackLayers) - 1;

    // skip layers that are not used by the current pixel
    for (; layer >= 0; --layer)
    {
        data = pathStackData[layer * elementsPerLayer + pixelIndex];

        // -1 is background, -2 is initialized/not used
        if (data.materialID >= -1)
            break;
    }

    float div = 0;

    // last ray hit background, or no hits at all
    if (data.materialID == -1)
    {
        --layer;

        float k = 1 - (float(layer) / float(numStackLayers));
        color += k * getBackgroundColor(data.lightColor.xyz);
        div += k;
    }

    uint numSurfaceHits = layer >= 0 ? layer + 1 : 0;

    // ray hits on surfaces
    for (; layer >=0; --layer)
    {
        data = pathStackData[layer * elementsPerLayer + pixelIndex];

        float k = 1 - (float(layer) / float(numStackLayers));
        color += k * getColor(data) * data.lightColor;
        div += k;
    }

    if (div > 0)
        color /= div;

    imageStore(colorTexture, pixelCoords, color);
}
