#version 430
#extension GL_ARB_shading_language_include : require

layout (local_size_x = 16, local_size_y = 16) in;

#include </pathtracing/generic/camera.glsl>
#include </pathtracing/generic/random.glsl>
#include </pathtracing/generic/rayCast.glsl>
#include </pathtracing/generic/sampling.glsl>

#include </PATHTRACING_EXTENSIONS/materials>
#include </PATHTRACING_EXTENSIONS/rayCastingOutput>


uniform uint frameCounter;
uniform uint time;
uniform ivec2 viewportSize;

// camera
uniform vec3 eye;
uniform float zNear;
uniform float zFar;
uniform mat3 rayMatrix;

// normal/depth raycast
layout (binding = 0, rgba8) uniform image2D normalTexture;
layout (binding = 1, r32f) uniform image2D depthTexture;

const vec4 lightColor = vec4(1, 1, 1, 1);


layout (std430, binding = 1) writeonly buffer PathStackDataBuffer
{
	PathStackData pathStackData[];
};

layout (std430, binding = 2) writeonly buffer SecondOrderRays
{
	SecondOrderRay secondOrderRays[];
};

layout (binding = 0, offset = 0) uniform atomic_uint rayIndexCounter;


// required
bool rayCast(in Ray ray, out RayIntersection intersection);
void getMaterial(in RayIntersection intersection, out PathStackData stackData);


void main()
{
    // coarse sampling / anti-aliasing: see sampling.glsl
    bool coarseSamplingInit;
    uint coarseSubSampleId = getCoarseSubSampleId(frameCounter, coarseSamplingInit);

	CoarseSamplingWindow coarseWindow = coarseSamplingWindows[coarseSubSampleId];

	// trace the origin of the coarse window (minimal coordinate)
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy * coarseSamplingWindowSize + coarseWindow.origin);

    if (pixelCoords.x >= viewportSize.x || pixelCoords.y >= viewportSize.y)
        return;

	random_seed(vec2(pixelCoords) / vec2(viewportSize), int(time + frameCounter));

    vec2 aliasing = vec2(0);
    if (!coarseSamplingInit)
    {
        uint subpixel = frameCounter % numAntiAliasingFrames;
        uint x = subpixel % antiAliasingKernelSize;
        uint y = subpixel / antiAliasingKernelSize;
        aliasing = vec2(ivec2(x, y)) / (antiAliasingKernelSize - 1) - 0.5;
    }

    vec2 rayCoords = (vec2(pixelCoords) + 0.5 + aliasing) / vec2(viewportSize);

    Camera camera = Camera_new(eye, rayMatrix, zNear, zFar);
    Ray ray = Camera_ray(camera, rayCoords);


    vec3 normal = vec3(0.0);
    float depth = 1.0;

    RayIntersection intersection;
    bool rayHit = rayCast(ray, intersection);

    if (rayHit)
    {
        depth = Camera_depth(camera, intersection.t);
        normal = (intersection.normal + vec3(1.0)) * 0.5;

        SecondOrderRay secondOrderRay;
        secondOrderRay.pixel = pixelCoords;
        secondOrderRay.origin = intersection.nextRay.origin;
        secondOrderRay.direction = intersection.nextRay.direction;

        uint index = atomicCounterIncrement(rayIndexCounter);
        secondOrderRays[index] = secondOrderRay;
    }

    // accumulate color values (but only if we already rendered each pixel)
	if (!coarseSamplingInit)
    {
        float t = 1.0 / float(frameCounter - numCoarseSubSamples + 1);
        normal = (
            mix(imageLoad(normalTexture, pixelCoords).xyz,
            normal,
            t));

        depth = mix(
            imageLoad(depthTexture, pixelCoords).x,
            depth,
            t);
    }


    PathStackData stackData;
    if (rayHit)
        getMaterial(intersection, stackData);
    else
    {
        stackData.materialID = -1;
        stackData.lightColor.xyz = ray.direction;
    }

	if (coarseSamplingInit)
	{
		for (uint x = 0; x < coarseWindow.windowSize.x; ++x)
		for (uint y = 0; y < coarseWindow.windowSize.y; ++y)
		{
			ivec2 windowPixel = ivec2(pixelCoords + uvec2(x, y));

            // raycasted normals, depths and extended attributes
			imageStore(normalTexture, windowPixel, vec4(normal, 1.0));
			imageStore(depthTexture, windowPixel, vec4(depth));
            storeExtendedAttributes(windowPixel, rayHit, intersection);
		}
	}
	else
	{
        // raycasted normals, depths and extended attributes
		imageStore(normalTexture, pixelCoords, vec4(normal, 1.0));
		imageStore(depthTexture, pixelCoords, vec4(depth));
        storeExtendedAttributes(pixelCoords, rayHit, intersection);
	}

    uint index = pixelCoordsToIndex(pixelCoords, viewportSize);
    pathStackData[index] = stackData;
}
